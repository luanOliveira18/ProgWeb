"use strict";
var ScrollProgress;
! function (t) {
	t.t = class {
		constructor(t) {
			this.i = t
		}
		s(t) {
			this.i.style.top = `${t}px`
		}
		get o() {
			return this.i.getBoundingClientRect().height
		}
	}
}(ScrollProgress || (ScrollProgress = {})),
function (t) {
	t.h = class {
		constructor(t, i) {
			this.l = t, this.u = i
		}
		get Id() {
			return this.l
		}
		get o() {
			return this.u
		}
	}
}(ScrollProgress || (ScrollProgress = {})),
function (t) {
	t.g = class {
		constructor(i, r) {
			this.v = null, this.m = i, null != r && (this.v = new t.t(r)), this.P = this.M(i)
		}
		get S() {
			return this.P
		}
		p(t) {
			var i, r, s;
			if (null == this.v) return;
			let o = this.P.findIndex(i => i.Id == t.Id),
				n = this.P.filter((t, i) => {
					if (i < o + 1) return t.o
				}).map(t => t.o).reduce((t, i) => t + i),
				e = this.P[o].o,
				h = n - e + (null !== (r = null === (i = null === this || void 0 === this ? void 0 : this.v) || void 0 === i ? void 0 : i.o) && void 0 !== r ? r : 0) + e * t.Percent / 100;
			null === (s = null === this || void 0 === this ? void 0 : this.v) || void 0 === s || s.s(h)
		}
		I() {
			this.P = this.M(this.m)
		}
		M(i) {
			if (i.length < 1) throw new Error("Menu can not be empty!");
			return i.map(i => {
				var r, s;
				let o = null === (r = i.getAttribute("href")) || void 0 === r ? void 0 : r.replace("#", "");
				if (!o) throw new Error(`Menu item '${null===(s=i.textContent)||void 0===s?void 0:s.trim()}' has not link to paragraph.`);
				return new t.h(o, i.getBoundingClientRect().height)
			})
		}
	}
}(ScrollProgress || (ScrollProgress = {})),
function (t) {
	t.T = class {
		constructor(t, i, r, s) {
			this.l = t, this.$ = i, this.k = null !== s && void 0 !== s ? s : null, this.u = r
		}
		get Id() {
			return this.l
		}
		get C() {
			return this.$
		}
		get N() {
			return this.k
		}
		get o() {
			return this.u
		}
	}
}(ScrollProgress || (ScrollProgress = {})),
function (t) {
	t.R = class {
		constructor(i, r, s, o, n) {
			var e;
			this.H = 0, this.L = 0, this.A = null, this.U = 0, this.G = (() => null), this.O = (() => null), this.u = i, this.G = o, this.O = n, this.j(r), this.q = new t.g(Array.from(r.children), s), this.B = this.D(this.q.S), this.F(this.B, this.q.S), this.q.p(this.J), null === (e = this.G) || void 0 === e || e.call(this, this.J), window.addEventListener("scroll", () => this.K()), window.addEventListener("resize", () => this.V())
		}
		D(i) {
			let r = i.map(t => `#${t.Id}`).join(", ");
			return Array.from(document.querySelectorAll(r)).map((i, r, s) => {
				var o, n;
				let e = Math.round(i.getBoundingClientRect().top + window.pageYOffset - this.L) - 3,
					h = Math.round((null === (n = null === (o = s[r + 1]) || void 0 === o ? void 0 : o.getBoundingClientRect()) || void 0 === n ? void 0 : n.top) + window.pageYOffset - this.L) - 3;
				return h || (h = this.u), new t.T(i.getAttribute("id"), e, h - e, i.textContent)
			})
		}
		K() {
			var t;
			this.U = window.pageYOffset, this.q.p(this.J), null === (t = this.G) || void 0 === t || t.call(this, this.J)
		}
		get W() {
			var t, i;
			let r = null !== (t = this.B.find(t => {
				if (this.U >= t.C && this.U <= t.C + t.o) return t
			})) && void 0 !== t ? t : this.B[0];
			return r.Id != this.A && (null === (i = this.O) || void 0 === i || i.call(this, null === r || void 0 === r ? void 0 : r.Id), this.A = r.Id), r
		}
		get J() {
			let t = this.W,
				i = Math.round((this.U - t.C) / t.o * 100);
			return {
				Id: t.Id,
				Percent: i > 0 ? i : 0
			}
		}
		V() {
			clearTimeout(this.H), this.H = setTimeout(() => this.I(), 200)
		}
		j(t) {
			if (null == t) throw new Error("Menu body can't be NULL")
		}
		F(t, i) {
			i.every(i => {
				if (t.find(t => t.Id == i.Id)) return !0;
				throw new Error(`Menu item with id '${i.Id}' not linked for paragraph!`)
			})
		}
		I() {
			var t;
			this.u = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight), this.B = this.D(this.q.S), this.q.I(), this.q.p(this.J), null === (t = this.G) || void 0 === t || t.call(this, this.J)
		}
	}
}(ScrollProgress || (ScrollProgress = {})),
function (t) {
	t.Init = class {
		constructor(i, r, s, o) {
			let n = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight),
				e = this.X(i),
				h = this.X(r);
			this.Y = new t.R(n, h, e, s, o)
		}
		X(t) {
			if (null == t) return null;
			let i = document.querySelector(t);
			if (!i) throw new Error(`Element with selector '${t}' not found!`);
			return i
		}
	}
}(ScrollProgress || (ScrollProgress = {}));